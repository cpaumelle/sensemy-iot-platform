# main.py - Ingest Server Entry (Actility + Netmore + TTI Support)
# Version: 0.7.0 - 2025-08-05 10:35 UTC
# Changelog:
# - Added deduplication logic before inserting into raw_uplinks

from fastapi import FastAPI, HTTPException, Request
import os, json, logging
from datetime import datetime, timedelta
import psycopg2
from fastapi.middleware.cors import CORSMiddleware
from dateutil.parser import isoparse

from forwarders.transform_forwarder import forward_to_transform
from parsers.actility_parser import parse_actility
from parsers.netmore_parser import parse_netmore
from parsers.tti_parser import parse_tti

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

app = FastAPI()

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"], allow_credentials=True,
    allow_methods=["*"], allow_headers=["*"]
)

DB_HOST = os.getenv("INGEST_DB_HOST", "localhost")
DB_PORT = os.getenv("INGEST_DB_INTERNAL_PORT", "5432")
DB_NAME = os.getenv("INGEST_DB_NAME", "ingest_db")
DB_USER = os.getenv("INGEST_DB_USER", "ingestuser")
DB_PASS = os.getenv("INGEST_DB_PASSWORD", "secret")

def get_conn():
    return psycopg2.connect(
        host=DB_HOST, port=DB_PORT,
        dbname=DB_NAME, user=DB_USER, password=DB_PASS
    )

@app.post("/uplink")
async def receive_uplink(req: Request):
    try:
        source = req.query_params.get("source", "").lower()
        body = await req.body()
        created_at = datetime.utcnow()
        logger.info(f"üõ∞Ô∏è  Incoming request on /uplink from source={source or 'auto'}: {body}")

        payload = json.loads(body.decode("utf-8")) if body else {}

        # Auto-detect LNS type
        if not source:
            if isinstance(payload, dict):
                if "DevEUI_uplink" in payload:
                    source = "actility"
                elif "end_device_ids" in payload:
                    source = "tti"
            elif isinstance(payload, list):
                if payload and isinstance(payload[0], dict) and "devEui" in payload[0]:
                    source = "netmore"

        # Normalize uplink using correct parser
        if source == "actility":
            uplink_data = parse_actility(payload)
        elif source == "netmore":
            if isinstance(payload, list) and len(payload) > 0:
                uplink_data = parse_netmore(payload[0])
            else:
                raise ValueError("Expected array of Netmore payloads")
        elif source == "tti":
            uplink_data = parse_tti(payload)
        else:
            raise ValueError(f"Unknown or unsupported source: {source}")

        deveui = uplink_data["deveui"]
        if not deveui:
            raise ValueError("Missing DevEUI in parsed payload")

        received_at = uplink_data["received_at"]
        payload_hex = uplink_data["payload"]

        # Deduplication check (last 30s, same deveui+payload+timestamp)
        try:
            with get_conn() as conn:
                with conn.cursor() as cur:
                    cur.execute("""
                        SELECT COUNT(*) FROM ingest.raw_uplinks
                        WHERE deveui = %s
                          AND payload = %s
                          AND received_at = %s
                          AND received_at > NOW() - INTERVAL '30 seconds'
                    """, (deveui, payload_hex, received_at))
                    duplicate_count = cur.fetchone()[0]

                    if duplicate_count > 0:
                        logger.info(f"‚ö†Ô∏è  Duplicate uplink skipped for {deveui} @ {received_at}")
                        return {"status": "duplicate-skipped", "deveui": deveui}

        except Exception as e:
            logger.warning(f"‚ö†Ô∏è Deduplication check failed, proceeding anyway: {e}")

        # Insert into ingest.raw_uplinks
        try:
            with get_conn() as conn:
                with conn.cursor() as cur:
                    cur.execute("""
                        INSERT INTO ingest.raw_uplinks (deveui, received_at, fport, payload, uplink_metadata, source, gateway_eui)
                        VALUES (%s, %s, %s, %s, %s, %s, %s)
                        RETURNING uplink_id
                    """, (
                        deveui,
                        received_at,
                        uplink_data.get("fport"),
                        payload_hex,
                        json.dumps(uplink_data["uplink_metadata"]),
                        source,
                        uplink_data.get("gateway_eui")
                    ))
                    ingest_id = cur.fetchone()[0]
                    conn.commit()
        except Exception as e:
            logger.error(f"‚ùå DB insert failed: {e}", exc_info=True)
            raise HTTPException(status_code=500, detail=f"Database insert error: {e}")

        # Forward to Transform
        forward_payload = {
            "deveui": deveui,
            "received_at": received_at.isoformat(),
            "fport": uplink_data.get("fport"),
            "payload": payload_hex,
            "uplink_metadata": uplink_data["uplink_metadata"],
            "source": source,
            "ingest_id": ingest_id,
            "gateway_eui": uplink_data.get("gateway_eui"),
        }

        logger.info(f"üì§ Forwarding to Transform: {json.dumps(forward_payload, indent=2)}")
        await forward_to_transform(forward_payload)

        logger.info(f"‚úîÔ∏è Stored and forwarded uplink for {deveui}")
        return {"status": "stored-and-forwarded", "deveui": deveui}

    except Exception as e:
        logger.error(f"Unhandled error: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/health")
def health_check():
    return {"status": "ok"}
