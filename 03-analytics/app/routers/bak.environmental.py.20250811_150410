# routers/environmental.py - Analytics
# Version: 1.0.0 - 2025-08-11 19:05:00 UTC
# Based on: Transform service router patterns and aggregations.py
# Environmental analytics endpoints using data-dictionary-driven materialized views

from fastapi import APIRouter, HTTPException, Depends, Query
from sqlalchemy.orm import Session
from sqlalchemy import desc, asc
from typing import List, Optional
from datetime import datetime, timedelta
from database.connections import get_sync_db_session
from models import EnvironmentalHourly, EnvironmentalLatest, DeviceHealthLatest, DataDictionary

router = APIRouter(tags=["Environmental Analytics"])

@router.get("/latest", response_model=List[dict])
def get_environmental_latest(
    deveui: Optional[str] = Query(None, description="Filter by specific device EUI"),
    device_type_id: Optional[int] = Query(None, description="Filter by device type"),
    site_id: Optional[str] = Query(None, description="Filter by site"),
    status: Optional[str] = Query(None, description="Filter by environmental status"),
    limit: int = Query(50, description="Maximum number of results"),
    db: Session = Depends(get_sync_db_session)
):
    """
    Get latest environmental readings from all environmental sensors
    
    Uses data-dictionary-driven normalization for consistent units and precision.
    Separates environmental data (temp/humidity/CO2) from device health.
    """
    query = db.query(EnvironmentalLatest)
    
    # Apply filters
    if deveui:
        query = query.filter(EnvironmentalLatest.deveui == deveui)
    if device_type_id:
        query = query.filter(EnvironmentalLatest.device_type_id == device_type_id)
    if site_id:
        query = query.filter(EnvironmentalLatest.site_id == site_id)
    if status:
        query = query.filter(EnvironmentalLatest.environmental_status == status)
    
    # Order by most recent first
    results = query.order_by(desc(EnvironmentalLatest.timestamp)).limit(limit).all()
    
    return [result.as_dict() for result in results]

@router.get("/latest/{deveui}", response_model=dict)
def get_device_environmental_latest(
    deveui: str,
    db: Session = Depends(get_sync_db_session)
):
    """Get latest environmental reading for specific device"""
    result = db.query(EnvironmentalLatest).filter_by(deveui=deveui).first()
    if not result:
        raise HTTPException(status_code=404, detail=f"No environmental data found for device {deveui}")
    return result.as_dict()

@router.get("/hourly", response_model=List[dict])
def get_environmental_hourly(
    deveui: Optional[str] = Query(None, description="Filter by specific device EUI"),
    device_type_id: Optional[int] = Query(None, description="Filter by device type"),
    site_id: Optional[str] = Query(None, description="Filter by site"),
    hours: int = Query(24, description="Number of hours to retrieve (default 24)"),
    limit: int = Query(100, description="Maximum number of results"),
    db: Session = Depends(get_sync_db_session)
):
    """
    Get hourly aggregated environmental data
    
    Returns temperature, humidity, and CO2 aggregations (min/avg/max) per hour.
    Uses data-dictionary-driven field mapping and units.
    """
    # Calculate time window
    since_time = datetime.utcnow() - timedelta(hours=hours)
    
    query = db.query(EnvironmentalHourly).filter(
        EnvironmentalHourly.hour_bucket >= since_time
    )
    
    # Apply filters
    if deveui:
        query = query.filter(EnvironmentalHourly.deveui == deveui)
    if device_type_id:
        query = query.filter(EnvironmentalHourly.device_type_id == device_type_id)
    if site_id:
        query = query.filter(EnvironmentalHourly.site_id == site_id)
    
    # Order by time and device
    results = query.order_by(
        desc(EnvironmentalHourly.hour_bucket),
        asc(EnvironmentalHourly.deveui)
    ).limit(limit).all()
    
    return [result.as_dict() for result in results]

@router.get("/hourly/{deveui}", response_model=List[dict])
def get_device_environmental_hourly(
    deveui: str,
    hours: int = Query(24, description="Number of hours to retrieve"),
    db: Session = Depends(get_sync_db_session)
):
    """Get hourly environmental aggregations for specific device"""
    since_time = datetime.utcnow() - timedelta(hours=hours)
    
    results = db.query(EnvironmentalHourly).filter(
        EnvironmentalHourly.deveui == deveui,
        EnvironmentalHourly.hour_bucket >= since_time
    ).order_by(desc(EnvironmentalHourly.hour_bucket)).all()
    
    if not results:
        raise HTTPException(status_code=404, detail=f"No hourly environmental data found for device {deveui}")
    
    return [result.as_dict() for result in results]

@router.get("/health", response_model=List[dict])
def get_device_health(
    deveui: Optional[str] = Query(None, description="Filter by specific device EUI"),
    device_type_id: Optional[int] = Query(None, description="Filter by device type"),
    health_status: Optional[str] = Query(None, description="Filter by overall health status"),
    battery_status: Optional[str] = Query(None, description="Filter by battery status"),
    limit: int = Query(50, description="Maximum number of results"),
    db: Session = Depends(get_sync_db_session)
):
    """
    Get device health status (battery, connectivity, overall health)
    
    Separated from environmental data following the established pattern.
    Uses device_type_thresholds for battery level assessment.
    """
    query = db.query(DeviceHealthLatest)
    
    # Apply filters
    if deveui:
        query = query.filter(DeviceHealthLatest.deveui == deveui)
    if device_type_id:
        query = query.filter(DeviceHealthLatest.device_type_id == device_type_id)
    if health_status:
        query = query.filter(DeviceHealthLatest.overall_health == health_status)
    if battery_status:
        query = query.filter(DeviceHealthLatest.battery_status == battery_status)
    
    # Order by health status (critical first) then by device
    results = query.order_by(
        DeviceHealthLatest.overall_health.desc(),  # critical > warning > healthy
        asc(DeviceHealthLatest.deveui)
    ).limit(limit).all()
    
    return [result.as_dict() for result in results]

@router.get("/health/{deveui}", response_model=dict)
def get_device_health_status(
    deveui: str,
    db: Session = Depends(get_sync_db_session)
):
    """Get health status for specific device"""
    result = db.query(DeviceHealthLatest).filter_by(deveui=deveui).first()
    if not result:
        raise HTTPException(status_code=404, detail=f"No health data found for device {deveui}")
    return result.as_dict()

@router.get("/summary", response_model=dict)
def get_environmental_summary(
    site_id: Optional[str] = Query(None, description="Filter by site"),
    db: Session = Depends(get_sync_db_session)
):
    """
    Get environmental summary statistics
    
    Provides overview of current environmental conditions and device health.
    """
    # Base queries
    env_query = db.query(EnvironmentalLatest)
    health_query = db.query(DeviceHealthLatest)
    
    if site_id:
        env_query = env_query.filter(EnvironmentalLatest.site_id == site_id)
        health_query = health_query.filter(DeviceHealthLatest.site_id == site_id)
    
    # Environmental summary
    env_devices = env_query.all()
    
    # Calculate environmental stats
    temps = [d.temperature for d in env_devices if d.temperature is not None]
    humidity_vals = [d.humidity for d in env_devices if d.humidity is not None]
    co2_vals = [d.co2_ppm for d in env_devices if d.co2_ppm is not None]
    
    # Health summary
    health_devices = health_query.all()
    health_counts = {}
    battery_counts = {}
    
    for device in health_devices:
        health_counts[device.overall_health] = health_counts.get(device.overall_health, 0) + 1
        battery_counts[device.battery_status] = battery_counts.get(device.battery_status, 0) + 1
    
    return {
        "environmental": {
            "total_devices": len(env_devices),
            "temperature": {
                "avg": round(sum(temps) / len(temps), 1) if temps else None,
                "min": min(temps) if temps else None,
                "max": max(temps) if temps else None,
                "unit": "Â°C"
            },
            "humidity": {
                "avg": round(sum(humidity_vals) / len(humidity_vals), 1) if humidity_vals else None,
                "min": min(humidity_vals) if humidity_vals else None,
                "max": max(humidity_vals) if humidity_vals else None,
                "unit": "%RH"
            },
            "co2": {
                "avg": round(sum(co2_vals) / len(co2_vals), 0) if co2_vals else None,
                "min": min(co2_vals) if co2_vals else None,
                "max": max(co2_vals) if co2_vals else None,
                "unit": "ppm"
            }
        },
        "device_health": {
            "total_devices": len(health_devices),
            "health_status": health_counts,
            "battery_status": battery_counts
        },
        "data_dictionary_fields": self._get_environmental_fields(db)
    }

def _get_environmental_fields(db: Session):
    """Helper to get environmental fields from data dictionary"""
    fields = db.query(DataDictionary).filter(
        DataDictionary.field_name.in_(['temperature', 'humidity', 'co2_ppm']),
        DataDictionary.device_type_id.in_([1, 2, 4])  # Environmental sensors
    ).all()
    
    return {
        field.device_type_id: {
            "field_name": field.field_name,
            "unit": field.unit,
            "precision": field.precision,
            "description": field.description
        } for field in fields
    }

@router.get("/devices/types", response_model=List[dict])
def get_environmental_device_types(
    db: Session = Depends(get_sync_db_session)
):
    """Get environmental device types with their data dictionary fields"""
    # Get environmental device types from latest readings
    device_types = db.query(
        EnvironmentalLatest.device_type_id,
        EnvironmentalLatest.device_type
    ).distinct().all()
    
    result = []
    for device_type_id, device_type in device_types:
        # Get data dictionary fields for this device type
        fields = db.query(DataDictionary).filter(
            DataDictionary.device_type_id == device_type_id,
            DataDictionary.field_name.in_(['temperature', 'humidity', 'co2_ppm'])
        ).all()
        
        # Count devices of this type
        device_count = db.query(EnvironmentalLatest).filter(
            EnvironmentalLatest.device_type_id == device_type_id
        ).count()
        
        result.append({
            "device_type_id": device_type_id,
            "device_type": device_type,
            "device_count": device_count,
            "supported_fields": [field.as_dict() for field in fields]
        })
    
    return result
